[
["index.html", "Volleyball analytics snippets 1 Introduction openvolley Acknowledgements", " Volleyball analytics snippets Ben Raymond, Adrien Ickowicz 1 Introduction This document provides some code snippets and guidance that might help you with volleyball analytics in R, and in particular with the openvolley family of packages. openvolley The openvolley project aims to provide an open-source, freely available software ecosystem to support volleyball analytics. It consists of a family of add-on packages that can be used with the R software. See http://openvolley.org. Acknowledgements "],
["setup.html", "2 Setup", " 2 Setup Some packages (including those from openvolley project) are hosted on GitHub. You will need the remotes package to install these, so first install that if needed: if (!requireNamespace(&quot;remotes&quot;, quietly = TRUE)) install.packages(&quot;remotes&quot;) Volleyball-specific packages: For users working with DataVolley files: remotes::install_github(&quot;openvolley/datavolley&quot;) VBStats users will additionally need the peranavolley package: remotes::install_github(&quot;openvolley/peranavolley&quot;) "],
["reading-files.html", "3 Reading files 3.1 DataVolley 3.2 VBStats 3.3 Reading multiple files", " 3 Reading files 3.1 DataVolley library(datavolley) filename &lt;- &quot;c:/my/filename.dvw&quot; x &lt;- dv_read(filename) The dv_read function has a number of optional parameters. The most important are probably: insert_technical_timeouts. By default, technical timeouts will be inserted at points 8 and 16 of sets 1–4 (for indoor files) or when the team scores sum to 21 in sets 1–2 (beach). You can avoid inserting technical timeouts by setting this to FALSE, or change the scores at which TTs are inserted (see dv_read function help) skill_evaluation_decode. By default, dv_read uses the standard DataVolley scouting conventions. This controls the interpretation of the evaluation codes (e.g. B/ is a block invasion (net touch or other violation)). However, not all scouts use these conventions. VolleyMetrics, for example, use B/ to mean a poor block that the opposition can replay (amongst other convention differences). In Germany, B/ is usually used to indicate a block tool (attack off the block for a kill) and B= is used to indicate an invasion. You can tell the dv_read function to follow these conventions by dv_read(..., skill_evaluation_decode = \"volleymetrics\") or dv_read(..., skill_evaluation_decode = \"german\"). If your files use other scouting conventions, you can write your own decoder (see dv_read function help) date_format. Dates can be ambiguous in DataVolley files, and sometimes they will be parsed incorrectly (e.g. swapping month and day). If the dates in your files are being read incorrectly you can set the expected format, e.g. dv_read(..., date_format = \"dmy\") or dv_read(..., date_format = \"mdy\"). encoding specifies the text encoding of the file. By default this will be guessed, but if the text encoding is guessed incorrectly then player/team names might appear garbled (e.g. accented characters wrong) and in extreme cases the file might refuse to read altogether. You can get an idea of what is going on with text encoding by asking for verbose output: dv_read(..., verbose = TRUE). You can set the text encoding by e.g. dv_read(..., encoding = \"windows-1252\") 3.2 VBStats library(peranavolley) x &lt;- pv_read(&quot;c:/my/filename.psvb&quot;) 3.3 Reading multiple files You might want to read multiple files in and analyze them all together. First find all of the DataVolley files in the target directory: d &lt;- dir(&quot;c:/data&quot;, pattern = &quot;dvw$&quot;, full.names = TRUE) ## if your files are in nested directories, add &#39;recursive = TRUE&#39; to the arguments Read all of those files in a loop, extract the play-by-play component from each, and then join of those all together: lx &lt;- list() for (fi in seq_along(d)) lx[[fi]] &lt;- plays(dv_read(d[fi], insert_technical_timeouts = FALSE)) px &lt;- do.call(rbind, lx) Note, the idiomatic R way to do this would be to use lapply instead of a for loop: lx &lt;- lapply(d, dv_read, insert_technical_timeouts = FALSE) px &lt;- do.call(rbind, lapply(lx, plays)) It achieves the same thing. Use whichever you prefer. Similarly, you could also use dplyr’s bind_rows function instead of do.call(rbind, ...): library(dplyr) px &lt;- bind_rows(lapply(lx, plays)) "],
["file-validation.html", "4 File validation", " 4 File validation Check the messages component of a datavolley or peranavolley object for the results of file validation and checking. This can help improve the consistency of your files and therefore of any subsequent analyses that you might conduct. x &lt;- dv_read(dv_example_file(2)) x$messages file_line_number video_time message file_line NA NA Home team (ACH Volley) player Daniel Lewis has no position (opposite/outside/etc) assigned in the players list NA 107 NA Consecutive actions by the same player a08AM-;;r;;;;;20.13.39;1;6;6;;;;8;10;6;1;16;15;7;1;14;8;4;5; 183 NA Unexpected skill type: N for skill: S *01SN!;;;;;;;20.21.01;1;3;3;;;;1;16;15;8;10;6;15;4;5;7;1;14; 184 NA Unexpected skill type: N for skill: R a15RN+;;;;;;;20.21.01;1;3;3;;;;1;16;15;8;10;6;15;4;5;7;1;14; 233 NA Consecutive actions by the same player a07AM-;;r;;;;;20.25.58;1;5;5;;;;10;6;1;16;15;8;1;14;15;4;5;7; 270 NA Consecutive actions by the same player *01AH-;;r;;;;;20.28.44;1;4;3;;;;6;1;16;15;8;10;15;2;5;17;1;14; 291 NA Consecutive actions by the same player a15AM#;s;r;;;;;20.33.03;2;1;2;;;;15;8;10;6;1;16;4;5;17;1;14;15; 304 NA Consecutive actions by the same player a15AM#;s;r;;;;;20.33.57;2;6;1;;;;8;10;6;1;16;15;5;17;1;14;15;4; 314 NA Consecutive actions by the same player a17AM-;;r;;;;;20.34.41;2;5;6;;;;10;6;1;16;15;8;17;1;14;15;4;5; 344 NA Consecutive actions by the same player *01AM#;s;r;;;;;20.36.43;2;5;5;;;;10;6;1;16;15;8;1;14;15;4;5;17; 357 NA Consecutive actions by the same player *08AM#;s;r;;;;;20.37.47;2;4;4;;;;6;1;16;15;8;10;14;15;4;5;17;1; 379 NA Consecutive actions by the same player a17AM/;p;r;;;;;20.40.37;2;2;3;;;;16;15;8;10;6;1;15;4;5;17;1;14; 564 NA Consecutive actions by the same player a07AH/;p;r;;;;;20.59.39;3;1;1;;;;15;8;10;6;1;16;5;7;1;14;15;4; 576 NA Consecutive actions by the same player a07AM-;;r;;;;;21.01.22;3;1;1;;;;15;8;10;6;1;16;5;7;1;14;15;4; 583 NA Consecutive actions by the same player a07AM-;;r;;;;;21.01.44;3;1;1;;;;15;8;10;6;1;16;5;7;1;14;15;4; 617 NA Block by a back-row player a07BM+;;;;;;;21.05.44;3;6;6;;;;8;10;6;1;16;15;7;1;14;15;4;5; 663 NA Rally does not include a winning or losing action *p17:07;;;;;;;21.10.01;3;3;2;;;;1;16;15;8;10;6;2;5;7;1;14;15; 691 NA Repeated row with same skill and evaluation_code for the same player *08AM-;;s;;;;;21.12.15;3;2;1;;;;16;15;8;10;6;1;6;7;1;14;15;2; Note that not all warnings will necessarily correspond to actual scouting errors. This particular file was scouted without all actions (in particular, not all setting actions). The warnings about “Consecutive actions by the same player” are to do with a player receiving or digging the ball and then making the next attack (but the intervening set action was not scouted). This probably doesn’t matter, so long as you are aware of this when analyzing the files. "],
["general-stuff.html", "5 General stuff", " 5 General stuff It may be better to use the evaluation column instead of the evaluation_code column for filtering and other data operations. Different scouting conventions mean that the entries in the evaluation_code column don’t always mean the same thing. For example, a block scouted as B/ is an invasion (net touch or other violation) according to the default DataVolley conventions, but some scouts instead use B/ to indicate a block tool, and others use it to indicate a poor block back to the opposition team. When a file is read into R with dv_read, the evaluation codes are converted into strings (stored in the evaluation column) following the conventions specified by the skill_evaluation_decode argument. Using the evaluation column is therefore likely to be more robust than the evaluation_code column, especially if your code is to be used on files collected by different scouts. For example, find block invasions by x %&gt;% dplyr::filter(skill == &quot;Block&quot; &amp; evaluation == &quot;Invasion&quot;) rather than by x %&gt;% dplyr::filter(skill == &quot;Block&quot; &amp; evaluation_code == &quot;/&quot;) "],
["court-plots.html", "6 Court plots 6.1 Background on location information 6.2 Plotting by zone or subzone 6.3 Plotting by line segment 6.4 Heatmaps 6.5 Changing direction 6.6 Plotting mid-coordinates", " 6 Court plots 6.1 Background on location information 6.1.1 Zones and subzones Scouts using DataVolley make use of zones (and optionally subzones) for all skills. Cones can alternatively be used for attack directions (instead of recording the end zone). Attacks cannot be scouted with both zones and cones in one file, DataVolley supports only one or the other. The zone/cone associated with each action is stored in the DataVolley file as the zone/cone number, without any inherent direction (side of the court) and without any actual location information. To plot the location of an action on a court diagram, we first generate actual court coordinates using the dv_xy() function. We pass it the zone number and which end of the court diagram (upper or lower) we wish to plot onto — let’s say an action from zone 4: dv_xy(zones = 4, end = &quot;lower&quot;) #&gt; x y #&gt; 1 1 3 So zone 4 is located at x = 1 and y = 3. The coordinate system used by openvolley packages looks like this: 6.1.2 Coordinates Actions can also be scouted with coordinates (the more precise locations, that are entered with the mouse click on the small court diagram). These are stored separately to the zone information in the DataVolley file. Coordinates can be used alongside of zones or cones, but not all scouts use coordinates. Coordinates are stored in the file as a single index from 1-10000, where 1 starts in the bottom-left on the lower side of the court diagram, across the row to 100 at the bottom-right, and it fills row-wise until 9901 is the top-left on the upper side of the court diagram and 10000 is the top-right. That covers both sides of the court, so coordinates are stored in the dvw file with an actual court location (and side) associated with them. When a DataVolley file is read into R using dv_read, these coordinates are stored without alteration in the start_coordinate, mid_coordinate, and end_coordinate columns. They are also converted to the same reference system shown above (using the dv_index2xy() function), and these values stored in the start_coordinate_x, start_coordinate_y, mid_coordinate_x, mid_coordinate_y, end_coordinate_x, and end_coordinate_y columns. 6.1.3 VBStats VBStats files use only coordinates internally, and on a different native grid to the DataVolley grid. When a VBStats file is read into R using the pv_read function, these coordinates are converted to the same coordinate system used above. Each coordinate is also converted to its corresponding zone and subzone, so these are also available when using VBStats files in R, even though VBStats itself doesn’t allow scouting with zones and subzones. 6.2 Plotting by zone or subzone library(ggplot2) library(dplyr) x &lt;- dv_read(dv_example_file(1)) ## calculate attack frequency by zone, per team attack_rate &lt;- plays(x) %&gt;% dplyr::filter(skill == &quot;Attack&quot;) %&gt;% group_by(team, start_zone) %&gt;% dplyr::summarize(n_attacks = n()) %&gt;% mutate(rate = n_attacks/sum(n_attacks)) %&gt;% ungroup ## add x, y coordinates associated with the zones attack_rate &lt;- cbind(attack_rate, dv_xy(attack_rate$start_zone, end = &quot;lower&quot;)) ## additionally specify the subzone to dv_xy if you want to plot by subzone (and your data ## were scouted with subzones) ## for team 2, these need to be on the top half of the diagram tm2i &lt;- attack_rate$team == teams(x)[2] attack_rate[tm2i, c(&quot;x&quot;, &quot;y&quot;)] &lt;- dv_flip_xy(attack_rate[tm2i, c(&quot;x&quot;, &quot;y&quot;)]) ggplot(attack_rate, aes(x, y, fill = rate)) + geom_tile() + ggcourt(labels = teams(x)) + scale_fill_gradient2(name = &quot;Attack rate&quot;) 6.3 Plotting by line segment ## take just the serves from the play-by-play data xserves &lt;- subset(plays(x), skill == &quot;Serve&quot;) ## if the file had been scouted with coordinates included, we could plot them directly ## this file has no coordinates, so we&#39;ll fake some up for demo purposes coords &lt;- dv_fake_coordinates(&quot;serve&quot;, xserves$evaluation) xserves[, c(&quot;start_coordinate&quot;, &quot;start_coordinate_x&quot;, &quot;start_coordinate_y&quot;, &quot;end_coordinate&quot;, &quot;end_coordinate_x&quot;, &quot;end_coordinate_y&quot;)] &lt;- coords ## now we can plot these xserves$evaluation[!xserves$evaluation %in% c(&quot;Ace&quot;, &quot;Error&quot;)] &lt;- &quot;Other&quot; ggplot(xserves, aes(start_coordinate_x, start_coordinate_y, xend = end_coordinate_x, yend = end_coordinate_y, colour = evaluation)) + geom_segment(arrow = arrow(length = unit(2, &quot;mm&quot;), type = &quot;closed&quot;, angle = 20)) + scale_colour_manual(values = c(Ace = &quot;limegreen&quot;, Error = &quot;firebrick&quot;, Other = &quot;dodgerblue&quot;), name = &quot;Evaluation&quot;) + ggcourt(labels = c(&quot;Serving team&quot;, &quot;Receiving team&quot;)) 6.4 Heatmaps Heatmap-style plots can be generated using a kernel density estimator. This takes a discrete number of location observations and attempts to estimate their corresponding (continuous) distribution across the court. For example, take these attack ending coordinates: ggplot(x %&gt;% dplyr::filter(skill == &quot;Attack&quot;), aes(end_coordinate_x, end_coordinate_y)) + ggcourt(labels = NULL, court = &quot;upper&quot;) + geom_point(colour = &quot;dodgerblue&quot;) As a heatmap: ggplot(x %&gt;% dplyr::filter(skill == &quot;Attack&quot;), aes(end_coordinate_x, end_coordinate_y)) + stat_density_2d(geom = &quot;raster&quot;, aes_string(fill = &quot;..density..&quot;), contour = FALSE, h = 0.85, n = c(60, 120)) + scale_fill_distiller(palette = &quot;Spectral&quot;, guide = FALSE) + ggcourt(labels = NULL, court = &quot;upper&quot;) The h parameter controls the smoothness of the heatmap (this is the bandwidth of the kernel density estimator). If you need more control over the heatmap, you may need to call e.g. MASS::kde2d() directly to construct the heatmap layer and plot it with geom_tile. 6.5 Changing direction Coordinates might not appear in the dvw file in any particular orientation (i.e. starting consistently on one side of the court). xattack &lt;- x %&gt;% dplyr::filter(skill == &quot;Attack&quot;) ggplot(xattack, aes(start_coordinate_x, start_coordinate_y, xend = end_coordinate_x, yend = end_coordinate_y)) + ggcourt(labels = NULL) + geom_segment(colour = &quot;dodgerblue&quot;) If we wish to plot all attacks so that they start on the same side of the court, we first need to figure out which ones need to be flipped around. The centre line of the court is at y = 3.5, so we can find any attacks that start on the upper side: toflip &lt;- which(xattack$start_coordinate_y &gt; 3.5) And then flip just those attacks so that they start on the lower half of the court: xattack$start_coordinate_x[toflip] &lt;- dv_flip_x(xattack$start_coordinate_x[toflip]) xattack$start_coordinate_y[toflip] &lt;- dv_flip_y(xattack$start_coordinate_y[toflip]) xattack$mid_coordinate_x[toflip] &lt;- dv_flip_x(xattack$mid_coordinate_x[toflip]) xattack$mid_coordinate_y[toflip] &lt;- dv_flip_y(xattack$mid_coordinate_y[toflip]) xattack$end_coordinate_x[toflip] &lt;- dv_flip_x(xattack$end_coordinate_x[toflip]) xattack$end_coordinate_y[toflip] &lt;- dv_flip_y(xattack$end_coordinate_y[toflip]) Or a little more succinctly using dplyr functions: xattack[toflip, ] &lt;- xattack[toflip, ] %&gt;% mutate_at(c(&quot;start_coordinate_x&quot;, &quot;mid_coordinate_x&quot;, &quot;end_coordinate_x&quot;), dv_flip_x) %&gt;% mutate_at(c(&quot;start_coordinate_y&quot;, &quot;mid_coordinate_y&quot;, &quot;end_coordinate_y&quot;), dv_flip_y) Now plot it: ggplot(xattack, aes(start_coordinate_x, start_coordinate_y, xend = end_coordinate_x, yend = end_coordinate_y)) + ggcourt(labels = NULL) + geom_segment(colour = &quot;dodgerblue&quot;) 6.6 Plotting mid-coordinates The mid coordinates can be used by the scout to indicate e.g. an attack that deflected off the block. In these cases, it can be misleading to plot just the start and end locations connected by a straight line segment. Consider an attack that came off the block and went back into the attacker’s court — by plotting just the start and end points it would appear to go directly backwards. ## example data x &lt;- data.frame(start_coordinate_x = c(0.75, 0.8), start_coordinate_y = c(3.25, 3.25), mid_coordinate_x = c(NA, 1.4), mid_coordinate_y = c(NA, 3.5), end_coordinate_x = c(1.1, 2), end_coordinate_y = c(5.5, 1.5)) ggplot(x, aes(start_coordinate_x, start_coordinate_y, xend = end_coordinate_x, yend = end_coordinate_y)) + ggcourt(labels = NULL) + geom_segment(colour = &quot;dodgerblue&quot;, arrow = arrow(length = unit(2, &quot;mm&quot;), type = &quot;closed&quot;, angle = 20, ends = &quot;last&quot;)) In these cases it is better to plot the mid point as well, but we need to cope with the fact that some mid-coordinates will be missing (NA): ggplot(x, aes(start_coordinate_x, start_coordinate_y, xend = end_coordinate_x, yend = end_coordinate_y)) + ggcourt(labels = NULL) + ## lines with no midpoint geom_segment(data = x[is.na(x$mid_coordinate_x), ], colour = &quot;dodgerblue&quot;, arrow = arrow(length = unit(2, &quot;mm&quot;), type = &quot;closed&quot;, angle = 20, ends = &quot;last&quot;)) + ## start to mid for lines with midpoint, no ending arrow geom_segment(data = x[!is.na(x$mid_coordinate_x), ], aes(xend = mid_coordinate_x, yend = mid_coordinate_y), colour = &quot;dodgerblue&quot;) + ## mid to end for lines with midpoint geom_segment(data = x[!is.na(x$mid_coordinate_x), ], aes(x = mid_coordinate_x, y = mid_coordinate_y), colour = &quot;dodgerblue&quot;, arrow = arrow(length = unit(2, &quot;mm&quot;), type = &quot;closed&quot;, angle = 20, ends = &quot;last&quot;)) "]
]
