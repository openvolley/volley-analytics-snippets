[
["index.html", "Volleyball analytics snippets 1 Introduction openvolley Contributing 1.1 Contributors and acknowledgements", " Volleyball analytics snippets Ben Raymond, Adrien Ickowicz 1 Introduction This document provides some code snippets and guidance that might help you with volleyball analytics in R, and in particular with the openvolley family of packages. openvolley The openvolley project aims to provide an open-source, freely available software ecosystem to support volleyball analytics. It consists of a family of add-on packages that can be used with the R software package. R provides an enormous range of data manipulation, analysis, modelling, and graphical display functionality, including the ability to build interactive data analysis and visualisation apps. See http://openvolley.org. Contributing Have some code or corrections that you’d like to contribute to this project? Or a request for something you’d like to see covered? Please join in! Either: fork the GitHub repository, create a new branch with your changes, and submit a pull request; or open an issue (especially for requests); or contact the maintainers directly. Maintainers and contributors must follow this project’s code of conduct. Contribution guidelines if you are forking the repo and submitting a pull request, please create a new branch and make your changes there please follow the existing code styling and conventions existing examples typically use tidyverse functions (e.g. using x %&gt;% dplyr::filter(blah) rather than direct dataframe-indexing like x[blah, ]) — but base R code is perfectly fine too, particularly if it’s easier to understand if your code example should actually run and show an output, use x and/or px as your data inputs if possible. These are from the example file bundled with the datavolley package: x &lt;- dv_read(dv_example_file()) px &lt;- plays(x) Note that this example file does not have some information scouted (e.g. attack or serve coordinates). be aware that the project maintainers might modify your code to better fit the existing code style and document structure. 1.1 Contributors and acknowledgements "],
["setup.html", "2 Setup 2.1 Example data", " 2 Setup Some packages (including those from openvolley project) are hosted on GitHub. You will need the remotes package to install these, so first install that if needed: if (!requireNamespace(&quot;remotes&quot;, quietly = TRUE)) install.packages(&quot;remotes&quot;) Volleyball-specific packages: For users working with DataVolley files: remotes::install_github(&quot;openvolley/datavolley&quot;) VBStats users will additionally need the peranavolley package: remotes::install_github(&quot;openvolley/peranavolley&quot;) 2.1 Example data Load some data that we’ll use in this document for illustrative purposes: x &lt;- dv_read(dv_example_file(1)) px &lt;- plays(x) summary(x) #&gt; Match summary: #&gt; Date: 2015-01-25 #&gt; League: Finale mladinke #&gt; Teams: Braslovče (JERONČIČ ZORAN/MIHALINEC DAMIJANA) #&gt; vs #&gt; Nova KBM Branik (HAFNER MATJAŽ) #&gt; Result: 3-0 (25-16, 25-14, 25-22) #&gt; Duration: 67 minutes "],
["reading-files.html", "3 Reading files 3.1 DataVolley 3.2 VBStats 3.3 Reading multiple files", " 3 Reading files 3.1 DataVolley library(datavolley) filename &lt;- &quot;c:/my/filename.dvw&quot; x &lt;- dv_read(filename) The dv_read function has a number of optional parameters. The most important are probably: insert_technical_timeouts. By default, technical timeouts will be inserted at points 8 and 16 of sets 1–4 (for indoor files) or when the team scores sum to 21 in sets 1–2 (beach). You can avoid inserting technical timeouts by setting this to FALSE, or change the scores at which TTs are inserted (see dv_read function help) skill_evaluation_decode. By default, dv_read uses the standard DataVolley scouting conventions. This controls the interpretation of the evaluation codes (e.g. B/ is a block invasion (net touch or other violation)). However, not all scouts use these conventions. VolleyMetrics, for example, use B/ to mean a poor block that the opposition can replay (amongst other convention differences). In Germany, B/ is usually used to indicate a block tool (attack off the block for a kill) and B= is used to indicate an invasion. You can tell the dv_read function to follow these conventions by dv_read(..., skill_evaluation_decode = \"volleymetrics\") or dv_read(..., skill_evaluation_decode = \"german\"). If your files use other scouting conventions, you can write your own decoder (see dv_read function help) date_format. Dates can be ambiguous in DataVolley files, and sometimes they will be parsed incorrectly (e.g. swapping month and day). If the dates in your files are being read incorrectly you can set the expected format, e.g. dv_read(..., date_format = \"dmy\") or dv_read(..., date_format = \"mdy\"). encoding specifies the text encoding of the file. By default this will be guessed, but if the text encoding is guessed incorrectly then player/team names might appear garbled (e.g. accented characters wrong) and in extreme cases the file might refuse to read altogether. You can get an idea of what is going on with text encoding by asking for verbose output: dv_read(..., verbose = TRUE). You can set the text encoding by e.g. dv_read(..., encoding = \"windows-1252\") 3.2 VBStats library(peranavolley) x &lt;- pv_read(&quot;c:/my/filename.psvb&quot;) 3.3 Reading multiple files You might want to read multiple files in and analyze them all together. First find all of the DataVolley files in the target directory: d &lt;- dir(&quot;c:/data&quot;, pattern = &quot;dvw$&quot;, full.names = TRUE) ## if your files are in nested directories, add &#39;recursive = TRUE&#39; to the arguments Read all of those files in a loop, extract the play-by-play component from each, and then join of those all together: lx &lt;- list() ## read each file for (fi in seq_along(d)) lx[[fi]] &lt;- dv_read(d[fi], insert_technical_timeouts = FALSE) ## now extract the play-by-play component from each and bind them together px &lt;- list() for (fi in seq_along(lx)) px[[fi]] &lt;- plays(lx) px &lt;- do.call(rbind, px) Note, the idiomatic R way to do this would be to use lapply instead of for loops: lx &lt;- lapply(d, dv_read, insert_technical_timeouts = FALSE) px &lt;- do.call(rbind, lapply(lx, plays)) It achieves the same thing. Use whichever you prefer. Similarly, you could also use dplyr’s bind_rows function instead of do.call(rbind, ...): library(dplyr) px &lt;- bind_rows(lapply(lx, plays)) After these operations, we have lx, which is a list containing the full contents of every match file (including the match and team metadata), and px, which is just the play-by-play component of each (but all joined together, which makes it easy to analyze multiple matches at once). "],
["file-validation.html", "4 File validation", " 4 File validation Check the messages component of a datavolley or peranavolley object for the results of file validation and checking. This can help improve the consistency of your files and therefore of any subsequent analyses that you might conduct. x &lt;- dv_read(dv_example_file(2)) x$messages file_line_number video_time message file_line NA NA Home team (ACH Volley) player Daniel Lewis has no position (opposite/outside/etc) assigned in the players list NA 107 NA Consecutive actions by the same player a08AM-;;r;;;;;20.13.39;1;6;6;;;;8;10;6;1;16;15;7;1;14;8;4;5; 183 NA Unexpected skill type: N for skill: S *01SN!;;;;;;;20.21.01;1;3;3;;;;1;16;15;8;10;6;15;4;5;7;1;14; 184 NA Unexpected skill type: N for skill: R a15RN+;;;;;;;20.21.01;1;3;3;;;;1;16;15;8;10;6;15;4;5;7;1;14; 233 NA Consecutive actions by the same player a07AM-;;r;;;;;20.25.58;1;5;5;;;;10;6;1;16;15;8;1;14;15;4;5;7; 270 NA Consecutive actions by the same player *01AH-;;r;;;;;20.28.44;1;4;3;;;;6;1;16;15;8;10;15;2;5;17;1;14; 291 NA Consecutive actions by the same player a15AM#;s;r;;;;;20.33.03;2;1;2;;;;15;8;10;6;1;16;4;5;17;1;14;15; 304 NA Consecutive actions by the same player a15AM#;s;r;;;;;20.33.57;2;6;1;;;;8;10;6;1;16;15;5;17;1;14;15;4; 314 NA Consecutive actions by the same player a17AM-;;r;;;;;20.34.41;2;5;6;;;;10;6;1;16;15;8;17;1;14;15;4;5; 344 NA Consecutive actions by the same player *01AM#;s;r;;;;;20.36.43;2;5;5;;;;10;6;1;16;15;8;1;14;15;4;5;17; 357 NA Consecutive actions by the same player *08AM#;s;r;;;;;20.37.47;2;4;4;;;;6;1;16;15;8;10;14;15;4;5;17;1; 379 NA Consecutive actions by the same player a17AM/;p;r;;;;;20.40.37;2;2;3;;;;16;15;8;10;6;1;15;4;5;17;1;14; 564 NA Consecutive actions by the same player a07AH/;p;r;;;;;20.59.39;3;1;1;;;;15;8;10;6;1;16;5;7;1;14;15;4; 576 NA Consecutive actions by the same player a07AM-;;r;;;;;21.01.22;3;1;1;;;;15;8;10;6;1;16;5;7;1;14;15;4; 583 NA Consecutive actions by the same player a07AM-;;r;;;;;21.01.44;3;1;1;;;;15;8;10;6;1;16;5;7;1;14;15;4; 617 NA Block by a back-row player a07BM+;;;;;;;21.05.44;3;6;6;;;;8;10;6;1;16;15;7;1;14;15;4;5; 663 NA Rally does not include a winning or losing action *p17:07;;;;;;;21.10.01;3;3;2;;;;1;16;15;8;10;6;2;5;7;1;14;15; 691 NA Repeated row with same skill and evaluation_code for the same player *08AM-;;s;;;;;21.12.15;3;2;1;;;;16;15;8;10;6;1;6;7;1;14;15;2; Note that not all warnings will necessarily correspond to actual scouting errors. This particular file was scouted without all actions (in particular, not all setting actions). The warnings about “Consecutive actions by the same player” are to do with a player receiving or digging the ball and then making the next attack (but the intervening set action was not scouted). This probably doesn’t matter, so long as you are aware of this when analyzing the files. "],
["general-notes-and-tips.html", "5 General notes and tips", " 5 General notes and tips It may be better to use the evaluation column instead of the evaluation_code column for filtering and other data operations Different scouting conventions mean that the entries in the evaluation_code column don’t always mean the same thing. For example, a block scouted as B/ is an invasion (net touch or other violation) according to the default DataVolley conventions, but some scouts instead use B/ to indicate a block tool, and others use it to indicate a poor block back to the opposition team. When a file is read into R with dv_read, the evaluation codes are converted into strings (stored in the evaluation column) following the conventions specified by the skill_evaluation_decode argument. Using the evaluation column is therefore likely to be more robust than the evaluation_code column, especially if your code is to be used on files collected by different scouts. For example, find block invasions by px %&gt;% dplyr::filter(skill == &quot;Block&quot; &amp; evaluation == &quot;Invasion&quot;) rather than by px %&gt;% dplyr::filter(skill == &quot;Block&quot; &amp; evaluation_code == &quot;/&quot;) Identifiers There are a number of columns in the play-by-play data that are useful to identify different aspects of play match_id uniquely identifies the match set_number is the set number (1–5) within a match. If you want to uniquely identify a particular set (from amongst many matches) use the combination of match_id and set_number point_id identifies the rally number (point) within a match. Each rally (point) begins with a serve (or rotation fault). Timeouts and other non-action points might have their own point_id, so don’t rely on point_id values being consecutive from one rally to the next. point_id values are only unique within a match (so e.g. two different matches will both have a point with point_id value of 1 team_touch_id identifies the touches that a team makes while the ball is on their side of the net. So a serve will have a certain team_touch_id, then the reception, set, and attack made by the receiving team will all have the same team_touch_id (different to the serve’s team_touch_id). The following block, dig, set, and attack will have another team_touch_id, and so on. team_touch_id values are also only unique within a match the phase column identifies the phase of play: it can take the values Serve, Reception, or Transition. Note that a block made against a reception attack (the attack made by the receiving team immediately after receiving the serve) is considered to be Reception phase, but the dig made by the blocking team immediately after that (and every subsequent action in the rally) are Transition "],
["data-augmentation.html", "6 Data augmentation 6.1 The setter of a given attack 6.2 Setter player IDs 6.3 Reception quality", " 6 Data augmentation Some examples of adding extra columns to our play-by-play data in order to support particular analyses, or to make other data-wrangling tasks easier. 6.1 The setter of a given attack Aim: Identify the player who made the set associated with each attack (noting that some files might not have the setting action coded for all attacks, or even coded at all). px &lt;- px %&gt;% mutate(set_player_id = case_when(skill == &quot;Attack&quot; &amp; lag(skill) == &quot;Set&quot; &amp; team == lag(team) ~ lag(player_id)) (The set_player_id column will be NA when there is no matching set coded before the attack.) 6.2 Setter player IDs Aim: identify the player_id of the setter on court for each data row. The play-by-play data frame has home_player_id1, home_player_id2, …, home_player_id6, which give the player_id of the home team player currently in position 1, 2, …, and 6. It also has a home_setter_position column, which tells us which position the home team setter is in (1–6). So to create a home_setter_id column we simply need to extract the value in the home_player_idX column for each row of the data frame, where X is the value in the home_setter_position at each row. One way to do this is: px &lt;- px %&gt;% mutate(home_setter_id = case_when(home_setter_position == 1 ~ home_player_id1, home_setter_position == 2 ~ home_player_id2, home_setter_position == 3 ~ home_player_id3, home_setter_position == 4 ~ home_player_id4, home_setter_position == 5 ~ home_player_id5, home_setter_position == 6 ~ home_player_id6)) But that is rather cumbersome and inelegant. A more concise method is: px &lt;- px %&gt;% rowwise() %&gt;% mutate(home_setter_id = cur_data()[[paste0(&quot;home_player_id&quot;, home_setter_position)]]) %&gt;% ungroup 6.3 Reception quality Aim: add a column that tells us the reception quality associated with each rally. The reception quality for a given rally is found in the evaluation column of the row that has the skill value of “Reception”. We just need to propagate this value to all other rows associated with that particular rally. First we extract the reception quality for each rally (remember from the Identifiers section that the point_id value identifies the rally, but needs to be combined with match_id to be globally unique): rq &lt;- px %&gt;% dplyr::filter(skill == &quot;Reception&quot;) %&gt;% group_by(match_id, point_id) %&gt;% dplyr::summarize(reception_quality = if (n() == 1) .data$evaluation else NA_character_) %&gt;% ungroup So rq is a data.frame with the reception quality for each match_id and point_id combination. reception_quality will be NA if there was no reception (or more than one reception — perhaps due to a scouting error?) involved in that point. Now join rq back to our full plays dataframe: px &lt;- px %&gt;% left_join(rq, by = c(&quot;match_id&quot;, &quot;point_id&quot;)) So now we have reception_quality for all rows of the data frame. "],
["filtering-and-subsetting.html", "7 Filtering and subsetting 7.1 Attack after perfect or good reception 7.2 Players on court 7.3 First transition attack", " 7 Filtering and subsetting Some different examples of extracting particular parts of the play-by-play data. 7.1 Attack after perfect or good reception Aim: find attacks after perfect or good reception In the Reception quality section, we added a reception_quality column to our data frame. We can use this now to identify reception-phase attacks, in rallies where reception was good or perfect: px %&gt;% dplyr::filter(skill == &quot;Attack&quot; &amp; phase == &quot;Reception&quot; &amp; grepl(&quot;Perfect|Positive&quot;, reception_quality)) %&gt;% group_by(team) %&gt;% dplyr::summarize(kill_rate = mean(evaluation == &quot;Winning attack&quot;)) #&gt; # A tibble: 2 x 2 #&gt; team kill_rate #&gt; &lt;chr&gt; &lt;dbl&gt; #&gt; 1 Braslovče 0.333 #&gt; 2 Nova KBM Branik 0.222 7.2 Players on court Aim: to extract the subset of our plays dataframe that correspond to points where particular players were on court. First some helper functions: ## find rows where a single player is on court player_on_court &lt;- function(x, target_player_id, team = NULL) { if (!is.null(team)) team &lt;- match.arg(team, c(&quot;home&quot;, &quot;visiting&quot;)) ## &#39;team&#39; is optional here, if NULL then we look at both home and visiting teams idx &lt;- rep(FALSE, nrow(x)) if (is.null(team) || team == &quot;home&quot;) { idx &lt;- idx | x$home_player_id1 == target_player_id | x$home_player_id2 == target_player_id | x$home_player_id3 == target_player_id | x$home_player_id4 == target_player_id | x$home_player_id5 == target_player_id | x$home_player_id6 == target_player_id } if (is.null(team) || team == &quot;visiting&quot;) { idx &lt;- idx | x$visiting_player_id1 == target_player_id | x$visiting_player_id2 == target_player_id | x$visiting_player_id3 == target_player_id | x$visiting_player_id4 == target_player_id | x$visiting_player_id5 == target_player_id | x$visiting_player_id6 == target_player_id } idx[is.na(idx)] &lt;- FALSE idx } ## find rows where any of our target players are on court any_player_on_court &lt;- function(x, target_player_ids, team = NULL) { ## for each target player, find rows where they are on court out &lt;- lapply(target_player_ids, function(pid) player_on_court(x, target_player_id = pid, team = team)) ## and now find rows where ANY of those players were on court apply(do.call(cbind, out), 1, any) } ## find rows where all of our target players are on court all_players_on_court &lt;- function(x, target_player_ids, team = NULL) { ## for each target player, find rows where they are on court out &lt;- lapply(target_player_ids, function(pid) player_on_court(x, target_player_id = pid, team = team)) ## and now find rows where ALL of those players were on court apply(do.call(cbind, out), 1, all) } And then we can apply these functions, for example to find rows when both of the players with id BR5 and BR10 are on court: nrow(px) ## the number of rows in the full dataframe #&gt; [1] 1037 my_target_player_ids &lt;- c(&quot;BR5&quot;, &quot;BR10&quot;) px2 &lt;- px[all_players_on_court(px, my_target_player_ids), ] nrow(px2) ## the number of rows in the filtered dataframe #&gt; [1] 81 7.3 First transition attack Aim: find rows corresponding to the first transition attack opportunity in each rally (i.e. after the receiving team has attacked, find the first attack by the serving team). As noted in the Identifiers setion, each team’s dig-set-attack (or whatever touches they make on their side of the net) has a unique team_touch_id value. First we find the team_touch_id values for reception-phase play, and then add one to each to get the next team touch (i.e. the first transition play, by the other team — but note that this next touch also has to be part of the same point, so we keep track of point_id too): ttid &lt;- px %&gt;% dplyr::filter(skill == &quot;Reception&quot;) %&gt;% distinct(match_id, point_id, team_touch_id) %&gt;% mutate(team_touch_id = team_touch_id+1, is_fta = TRUE) ## join this to px px &lt;- px %&gt;% left_join(ttid, by = c(&quot;match_id&quot;, &quot;point_id&quot;, &quot;team_touch_id&quot;)) %&gt;% mutate(is_fta = case_when(is.na(is_fta) ~ FALSE, TRUE ~ is_fta)) ## clean up the NAs The px$is_fta column should be TRUE for all actions that are in first-transition play, and you can extract what you need from that (filter just the attacks, or whatever you need). "],
["court-plots.html", "8 Court plots 8.1 Background on location information 8.2 Plotting by zone or subzone 8.3 Plotting by line segment 8.4 Heatmaps 8.5 Changing direction 8.6 Plotting mid-coordinates", " 8 Court plots 8.1 Background on location information 8.1.1 Zones and subzones Scouts using DataVolley make use of zones (and optionally subzones) for all skills. Cones can alternatively be used for attack directions (instead of recording the end zone). Attacks cannot be scouted with both zones and cones in one file, DataVolley supports only one or the other. The zone/cone associated with each action is stored in the DataVolley file as the zone/cone number, without any inherent direction (side of the court) and without any actual location information. To plot the location of an action on a court diagram, we first generate actual court coordinates using the dv_xy() function. We pass it the zone number and which end of the court diagram (upper or lower) we wish to plot onto — let’s say an action from zone 4: dv_xy(zones = 4, end = &quot;lower&quot;) #&gt; x y #&gt; 1 1 3 So zone 4 is located at x = 1 and y = 3. The coordinate system used by openvolley packages looks like this: 8.1.2 Coordinates Actions can also be scouted with coordinates (the more precise locations, that are entered with the mouse click on the small court diagram). These are stored separately to the zone information in the DataVolley file. Coordinates can be used alongside of zones or cones, but not all scouts use coordinates. Coordinates are stored in the file as a single index from 1-10000, where 1 starts in the bottom-left on the lower side of the court diagram, across the row to 100 at the bottom-right, and it fills row-wise until 9901 is the top-left on the upper side of the court diagram and 10000 is the top-right. That covers both sides of the court, so coordinates are stored in the dvw file with an actual court location (and side) associated with them. When a DataVolley file is read into R using dv_read, these coordinates are stored without alteration in the start_coordinate, mid_coordinate, and end_coordinate columns. They are also converted to the same reference system shown above (using the dv_index2xy() function), and these values stored in the start_coordinate_x, start_coordinate_y, mid_coordinate_x, mid_coordinate_y, end_coordinate_x, and end_coordinate_y columns. 8.1.3 VBStats VBStats files use only coordinates internally, and on a different native grid to the DataVolley grid. When a VBStats file is read into R using the pv_read function, these coordinates are converted to the same coordinate system used above. Each coordinate is also converted to its corresponding zone and subzone, so these are also available when using VBStats files in R, even though VBStats itself doesn’t allow scouting with zones and subzones. 8.2 Plotting by zone or subzone library(ggplot2) library(dplyr) x &lt;- dv_read(dv_example_file(1)) ## calculate attack frequency by zone, per team px &lt;- plays(x) attack_rate &lt;- px %&gt;% dplyr::filter(skill == &quot;Attack&quot;) %&gt;% group_by(team, start_zone) %&gt;% dplyr::summarize(n_attacks = n()) %&gt;% mutate(rate = n_attacks/sum(n_attacks)) %&gt;% ungroup ## add x, y coordinates associated with the zones attack_rate &lt;- cbind(attack_rate, dv_xy(attack_rate$start_zone, end = &quot;lower&quot;)) ## additionally specify the subzone to dv_xy if you want to plot by subzone (and your data ## were scouted with subzones) ## for team 2, these need to be on the top half of the diagram tm2i &lt;- attack_rate$team == teams(x)[2] attack_rate[tm2i, c(&quot;x&quot;, &quot;y&quot;)] &lt;- dv_flip_xy(attack_rate[tm2i, c(&quot;x&quot;, &quot;y&quot;)]) ggplot(attack_rate, aes(x, y, fill = rate)) + geom_tile() + ggcourt(labels = teams(x)) + scale_fill_gradient2(name = &quot;Attack rate&quot;) 8.3 Plotting by line segment ## take just the serves from the play-by-play data xserves &lt;- subset(px, skill == &quot;Serve&quot;) ## if the file had been scouted with coordinates included, we could plot them directly ## this file has no coordinates, so we&#39;ll fake some up for demo purposes coords &lt;- dv_fake_coordinates(&quot;serve&quot;, xserves$evaluation) xserves[, c(&quot;start_coordinate&quot;, &quot;start_coordinate_x&quot;, &quot;start_coordinate_y&quot;, &quot;end_coordinate&quot;, &quot;end_coordinate_x&quot;, &quot;end_coordinate_y&quot;)] &lt;- coords ## now we can plot these xserves$evaluation[!xserves$evaluation %in% c(&quot;Ace&quot;, &quot;Error&quot;)] &lt;- &quot;Other&quot; ggplot(xserves, aes(start_coordinate_x, start_coordinate_y, xend = end_coordinate_x, yend = end_coordinate_y, colour = evaluation)) + geom_segment(arrow = arrow(length = unit(2, &quot;mm&quot;), type = &quot;closed&quot;, angle = 20)) + scale_colour_manual(values = c(Ace = &quot;limegreen&quot;, Error = &quot;firebrick&quot;, Other = &quot;dodgerblue&quot;), name = &quot;Evaluation&quot;) + ggcourt(labels = c(&quot;Serving team&quot;, &quot;Receiving team&quot;)) 8.4 Heatmaps Heatmap-style plots can be generated using a kernel density estimator. This takes a discrete number of location observations and attempts to estimate their corresponding (continuous) distribution across the court. For example, take these attack ending coordinates: ggplot(px2 %&gt;% dplyr::filter(skill == &quot;Attack&quot;), aes(end_coordinate_x, end_coordinate_y)) + ggcourt(labels = NULL, court = &quot;upper&quot;) + geom_point(colour = &quot;dodgerblue&quot;) As a heatmap: ggplot(px2 %&gt;% dplyr::filter(skill == &quot;Attack&quot;), aes(end_coordinate_x, end_coordinate_y)) + stat_density_2d(geom = &quot;raster&quot;, aes_string(fill = &quot;..density..&quot;), contour = FALSE, h = 0.85, n = c(60, 120)) + scale_fill_distiller(palette = &quot;Spectral&quot;, guide = FALSE) + ggcourt(labels = NULL, court = &quot;upper&quot;) The h parameter controls the smoothness of the heatmap (this is the bandwidth of the kernel density estimator). If you need more control over the heatmap, you may need to call e.g. MASS::kde2d() directly to construct the heatmap layer and plot it with geom_tile. 8.5 Changing direction Coordinates might not appear in the dvw file in any particular orientation (i.e. starting consistently on one side of the court). xattack &lt;- px2 %&gt;% dplyr::filter(skill == &quot;Attack&quot;) ggplot(xattack, aes(start_coordinate_x, start_coordinate_y, xend = end_coordinate_x, yend = end_coordinate_y)) + ggcourt(labels = NULL) + geom_segment(colour = &quot;dodgerblue&quot;) If we wish to plot all attacks so that they start on the same side of the court, we first need to figure out which ones need to be flipped around. The centre line of the court is at y = 3.5, so we can find any attacks that start on the upper side: toflip &lt;- which(xattack$start_coordinate_y &gt; 3.5) And then flip just those attacks so that they start on the lower half of the court: xattack$start_coordinate_x[toflip] &lt;- dv_flip_x(xattack$start_coordinate_x[toflip]) xattack$start_coordinate_y[toflip] &lt;- dv_flip_y(xattack$start_coordinate_y[toflip]) xattack$mid_coordinate_x[toflip] &lt;- dv_flip_x(xattack$mid_coordinate_x[toflip]) xattack$mid_coordinate_y[toflip] &lt;- dv_flip_y(xattack$mid_coordinate_y[toflip]) xattack$end_coordinate_x[toflip] &lt;- dv_flip_x(xattack$end_coordinate_x[toflip]) xattack$end_coordinate_y[toflip] &lt;- dv_flip_y(xattack$end_coordinate_y[toflip]) Or a little more succinctly using dplyr functions: xattack[toflip, ] &lt;- xattack[toflip, ] %&gt;% mutate_at(c(&quot;start_coordinate_x&quot;, &quot;mid_coordinate_x&quot;, &quot;end_coordinate_x&quot;), dv_flip_x) %&gt;% mutate_at(c(&quot;start_coordinate_y&quot;, &quot;mid_coordinate_y&quot;, &quot;end_coordinate_y&quot;), dv_flip_y) Now plot it: ggplot(xattack, aes(start_coordinate_x, start_coordinate_y, xend = end_coordinate_x, yend = end_coordinate_y)) + ggcourt(labels = NULL) + geom_segment(colour = &quot;dodgerblue&quot;) 8.6 Plotting mid-coordinates The mid coordinates can be used by the scout to indicate e.g. an attack that deflected off the block. In these cases, it can be misleading to plot just the start and end locations connected by a straight line segment. Consider an attack that came off the block and went back into the attacker’s court — by plotting just the start and end points it would appear to go directly backwards. ## example data px2 &lt;- data.frame(start_coordinate_x = c(0.75, 0.8), start_coordinate_y = c(3.25, 3.25), mid_coordinate_x = c(NA, 1.4), mid_coordinate_y = c(NA, 3.5), end_coordinate_x = c(1.1, 2), end_coordinate_y = c(5.5, 1.5)) ggplot(px2, aes(start_coordinate_x, start_coordinate_y, xend = end_coordinate_x, yend = end_coordinate_y)) + ggcourt(labels = NULL) + geom_segment(colour = &quot;dodgerblue&quot;, arrow = arrow(length = unit(2, &quot;mm&quot;), type = &quot;closed&quot;, angle = 20, ends = &quot;last&quot;)) In these cases it is better to plot the mid point as well, but we need to cope with the fact that some mid-coordinates will be missing (NA): ggplot(px2, aes(start_coordinate_x, start_coordinate_y, xend = end_coordinate_x, yend = end_coordinate_y)) + ggcourt(labels = NULL) + ## lines with no midpoint geom_segment(data = px2[is.na(px2$mid_coordinate_x), ], colour = &quot;dodgerblue&quot;, arrow = arrow(length = unit(2, &quot;mm&quot;), type = &quot;closed&quot;, angle = 20, ends = &quot;last&quot;)) + ## start to mid for lines with midpoint, no ending arrow geom_segment(data = px2[!is.na(px2$mid_coordinate_x), ], aes(xend = mid_coordinate_x, yend = mid_coordinate_y), colour = &quot;dodgerblue&quot;) + ## mid to end for lines with midpoint geom_segment(data = px2[!is.na(px2$mid_coordinate_x), ], aes(x = mid_coordinate_x, y = mid_coordinate_y), colour = &quot;dodgerblue&quot;, arrow = arrow(length = unit(2, &quot;mm&quot;), type = &quot;closed&quot;, angle = 20, ends = &quot;last&quot;)) "],
["odds-and-ends.html", "9 Odds and ends", " 9 Odds and ends To be moved elsewhere in the document … Counting the number of sets played by a team px %&gt;% dplyr::filter(!is.na(team)) %&gt;% distinct(team, match_id, set_number) %&gt;% count(team) "]
]
